import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
const supabaseUrl = Deno.env.get('SUPABASE_URL') || 'https://rpeejpqxprpacpzqmoel.supabase.co';
const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
const openAIApiKey = Deno.env.get('OPENAI_API_KEY');
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
};
serve(async (req)=>{
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, {
      headers: corsHeaders
    });
  }
  try {
    console.log('üöÄ === WEBHOOK RECEBIDO (SEM AUTENTICA√á√ÉO) ===');
    console.log('‚è∞ Timestamp:', new Date().toISOString());
    console.log('üîó Method:', req.method);
    console.log('üåê URL:', req.url);
    console.log('üìã Headers:', JSON.stringify([
      ...req.headers.entries()
    ]));
    const webhookData = await req.json();
    console.log('üì¶ Dados completos do webhook:', JSON.stringify(webhookData, null, 2));
    // Verificar diferentes formatos de webhook da Evolution API
    let messageData = null;
    let instanceName = null;
    let phoneNumber = null;
    let messageText = null;
    // Formato 1: messages.upsert (padr√£o Evolution)
    if (webhookData.event === 'messages.upsert' && webhookData.data) {
      console.log('‚úÖ Formato detectado: messages.upsert');
      messageData = webhookData.data;
      instanceName = webhookData.instance;
      if (messageData.key?.fromMe) {
        console.log('‚ö†Ô∏è Mensagem pr√≥pria ignorada (fromMe: true)');
        return new Response('OK - Mensagem pr√≥pria', {
          status: 200
        });
      }
      phoneNumber = messageData.key?.remoteJid?.replace('@s.whatsapp.net', '');
      messageText = messageData.message?.conversation || messageData.message?.extendedTextMessage?.text;
    } else if (webhookData.event === 'MESSAGES_UPSERT' && webhookData.data) {
      console.log('‚úÖ Formato detectado: MESSAGES_UPSERT');
      messageData = webhookData.data;
      instanceName = webhookData.instance;
      if (messageData.key?.fromMe) {
        console.log('‚ö†Ô∏è Mensagem pr√≥pria ignorada (fromMe: true)');
        return new Response('OK - Mensagem pr√≥pria', {
          status: 200
        });
      }
      phoneNumber = messageData.key?.remoteJid?.replace('@s.whatsapp.net', '');
      messageText = messageData.message?.conversation || messageData.message?.extendedTextMessage?.text;
    } else if (webhookData.message && webhookData.key) {
      console.log('‚úÖ Formato detectado: message direto');
      messageData = webhookData;
      instanceName = webhookData.instanceName || webhookData.instance;
      if (webhookData.key?.fromMe) {
        console.log('‚ö†Ô∏è Mensagem pr√≥pria ignorada (fromMe: true)');
        return new Response('OK - Mensagem pr√≥pria', {
          status: 200
        });
      }
      phoneNumber = webhookData.key?.remoteJid?.replace('@s.whatsapp.net', '');
      messageText = webhookData.message?.conversation || webhookData.message?.extendedTextMessage?.text;
    } else if (webhookData.instance && webhookData.data?.message) {
      console.log('‚úÖ Formato detectado: webhook por eventos');
      messageData = webhookData.data;
      instanceName = webhookData.instance;
      if (messageData.key?.fromMe) {
        console.log('‚ö†Ô∏è Mensagem pr√≥pria ignorada (fromMe: true)');
        return new Response('OK - Mensagem pr√≥pria', {
          status: 200
        });
      }
      phoneNumber = messageData.key?.remoteJid?.replace('@s.whatsapp.net', '');
      messageText = messageData.message?.conversation || messageData.message?.extendedTextMessage?.text;
    } else if (webhookData.key && webhookData.message) {
      console.log('‚úÖ Formato detectado: dados diretos');
      messageData = webhookData;
      instanceName = webhookData.instanceName || 'default';
      if (webhookData.key?.fromMe) {
        console.log('‚ö†Ô∏è Mensagem pr√≥pria ignorada (fromMe: true)');
        return new Response('OK - Mensagem pr√≥pria', {
          status: 200
        });
      }
      phoneNumber = webhookData.key?.remoteJid?.replace('@s.whatsapp.net', '');
      messageText = webhookData.message?.conversation || webhookData.message?.extendedTextMessage?.text;
    } else {
      console.log('‚ùå Formato n√£o reconhecido ou evento ignorado.');
      console.log('üîç Event:', webhookData.event);
      console.log('üìä Estrutura do webhook:', Object.keys(webhookData));
      console.log('üîç Dados completos para an√°lise:', JSON.stringify(webhookData, null, 2));
      // Log mais detalhado para depura√ß√£o
      if (webhookData.data) {
        console.log('üì¶ Dados dentro de .data:', JSON.stringify(webhookData.data, null, 2));
      }
      return new Response('OK - Evento ignorado ou formato n√£o reconhecido', {
        status: 200
      });
    }
    console.log('üéØ === DADOS EXTRA√çDOS ===');
    console.log('üè¢ Instance:', instanceName);
    console.log('üìû Phone:', phoneNumber);
    console.log('üí¨ Message:', messageText);
    // Valida√ß√µes mais rigorosas
    if (!instanceName) {
      console.log('‚ùå ERRO: instanceName n√£o encontrado');
      return new Response('OK - Instance name n√£o encontrado', {
        status: 200
      });
    }
    if (!phoneNumber) {
      console.log('‚ùå ERRO: phoneNumber n√£o encontrado');
      return new Response('OK - Phone number n√£o encontrado', {
        status: 200
      });
    }
    if (!messageText || messageText.trim().length === 0) {
      console.log('‚ùå ERRO: messageText vazio ou n√£o encontrado');
      return new Response('OK - Mensagem vazia', {
        status: 200
      });
    }
    // Limpar o n√∫mero de telefone
    phoneNumber = phoneNumber.replace(/[^\d]/g, '');
    console.log('üì± Telefone limpo:', phoneNumber);
    // Inicializar cliente Supabase
    if (!supabaseKey) {
      console.error('‚ùå ERRO: SUPABASE_SERVICE_ROLE_KEY n√£o configurada');
      return new Response(JSON.stringify({
        error: 'Configura√ß√£o do servidor incompleta'
      }), {
        status: 500,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    const supabase = createClient(supabaseUrl, supabaseKey);
    console.log('‚úÖ === SUPABASE INICIALIZADO ===');
    // Buscar a empresa pela inst√¢ncia do WhatsApp
    console.log('üîç Buscando empresa para inst√¢ncia:', instanceName);
    const { data: whatsappInstance, error: instanceError } = await supabase.from('whatsapp_instances').select('empresa_id').eq('instance_name', instanceName).single();
    if (instanceError || !whatsappInstance) {
      console.error('‚ùå ERRO: Inst√¢ncia n√£o encontrada:', instanceError);
      return new Response(JSON.stringify({
        error: 'Inst√¢ncia n√£o encontrada',
        instance: instanceName
      }), {
        status: 404,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    const empresaId = whatsappInstance.empresa_id;
    console.log('üè¢ Empresa encontrada:', empresaId);
    // Buscar configura√ß√µes de IA da empresa
    console.log('ü§ñ Buscando configura√ß√µes de IA...');
    const { data: configIA, error: configError } = await supabase.from('empresa_configuracoes_ia').select('*').eq('empresa_id', empresaId).eq('ativo', true).single();
    if (configError || !configIA) {
      console.log('‚ö†Ô∏è AVISO: IA n√£o configurada ou inativa para esta empresa');
      return new Response(JSON.stringify({
        message: 'IA n√£o configurada ou inativa',
        empresa_id: empresaId
      }), {
        status: 200,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    console.log('‚öôÔ∏è Configura√ß√µes de IA encontradas:', configIA);
    // Buscar configura√ß√µes do WhatsApp
    console.log('üì± Buscando configura√ß√µes do WhatsApp...');
    const { data: configs, error: configsError } = await supabase.from('configuracoes').select('chave, valor').in('chave', [
      'whatsappUrl',
      'whatsappChave'
    ]);
    if (configsError || !configs || configs.length < 2) {
      console.error('‚ùå ERRO: Configura√ß√µes do WhatsApp n√£o encontradas:', configsError);
      return new Response(JSON.stringify({
        error: 'Configura√ß√µes do WhatsApp n√£o encontradas'
      }), {
        status: 500,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    const whatsappConfig = configs.find((c)=>c.chave === 'whatsappUrl');
    const whatsappKey = configs.find((c)=>c.chave === 'whatsappChave');
    if (!whatsappConfig?.valor || !whatsappKey?.valor) {
      console.error('‚ùå ERRO: URLs ou chaves do WhatsApp n√£o configuradas');
      return new Response(JSON.stringify({
        error: 'Configura√ß√µes do WhatsApp incompletas'
      }), {
        status: 500,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    const evolutionUrl = whatsappConfig.valor;
    const evolutionApiKey = whatsappKey.valor;
    console.log('üì± Configura√ß√µes WhatsApp:', {
      url: evolutionUrl,
      hasKey: !!evolutionApiKey
    });
    console.log('ü§ñ === CHAMANDO FUN√á√ÉO CHAT-IA ===');
    // Chamar a fun√ß√£o chat-ia para obter resposta
    const { data: chatResponse, error: chatError } = await supabase.functions.invoke('chat-ia', {
      body: {
        message: messageText,
        empresa_id: empresaId,
        cliente_telefone: phoneNumber,
        configuracoes: {
          prompt_sistema: configIA.prompt_sistema,
          personalidade: configIA.personalidade,
          modelo: configIA.modelo,
          temperatura: configIA.temperatura,
          max_tokens: configIA.max_tokens
        }
      }
    });
    if (chatError) {
      console.error('‚ùå ERRO ao chamar chat-ia:', chatError);
      return new Response(JSON.stringify({
        error: 'Erro na fun√ß√£o chat-ia',
        details: chatError
      }), {
        status: 500,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    // CORRE√á√ÉO: Usar 'resposta' em vez de 'response'
    if (!chatResponse?.resposta) {
      console.error('‚ùå ERRO: Resposta da IA vazia:', chatResponse);
      return new Response(JSON.stringify({
        error: 'Resposta da IA vazia'
      }), {
        status: 500,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    console.log('ü§ñ Resposta da IA obtida:', chatResponse.resposta);
    console.log('üì§ === ENVIANDO RESPOSTA VIA EVOLUTION ===');
    // Usar EXATAMENTE o mesmo formato que funcionou no teste direto
    const sendMessageUrl = `${evolutionUrl}/message/sendText/${instanceName}`;
    const sendMessageBody = {
      number: phoneNumber,
      text: chatResponse.resposta
    };
    console.log('üì§ === ENVIANDO COM FORMATO QUE FUNCIONOU NO TESTE ===');
    console.log('üåê URL de envio:', sendMessageUrl);
    console.log('üì¶ Corpo da mensagem:', JSON.stringify(sendMessageBody, null, 2));
    console.log('üîë API Key configurada:', evolutionApiKey ? 'SIM' : 'N√ÉO');
    try {
      const evolutionResponse = await fetch(sendMessageUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': evolutionApiKey
        },
        body: JSON.stringify(sendMessageBody)
      });
      console.log('üìä Status da resposta Evolution:', evolutionResponse.status);
      console.log('üìã Headers da resposta Evolution:', JSON.stringify([
        ...evolutionResponse.headers.entries()
      ]));
      const evolutionResult = await evolutionResponse.text();
      console.log('üì§ Resposta da Evolution API (raw):', evolutionResult);
      let parsedResult;
      try {
        parsedResult = JSON.parse(evolutionResult);
        console.log('üì¶ Resposta da Evolution API (parsed):', JSON.stringify(parsedResult, null, 2));
      } catch (parseError) {
        console.log('‚ö†Ô∏è N√£o foi poss√≠vel fazer parse da resposta, mantendo como texto');
        parsedResult = {
          message: evolutionResult
        };
      }
      if (evolutionResponse.ok) {
        console.log('üéâ === SUCESSO: MENSAGEM ENVIADA ===');
        return new Response(JSON.stringify({
          success: true,
          message: 'Resposta enviada com sucesso',
          response: chatResponse.resposta,
          evolutionResponse: parsedResult
        }), {
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json'
          }
        });
      } else {
        console.error('‚ùå ERRO no envio:', evolutionResponse.status, evolutionResult);
        return new Response(JSON.stringify({
          error: 'Erro na Evolution API',
          status: evolutionResponse.status,
          details: parsedResult
        }), {
          status: 500,
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json'
          }
        });
      }
    } catch (fetchError) {
      console.error('‚ùå ERRO de conex√£o com Evolution API:', fetchError);
      return new Response(JSON.stringify({
        error: 'Erro de conex√£o com Evolution API',
        details: fetchError.message
      }), {
        status: 500,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
  } catch (error) {
    console.error('üí• === ERRO GERAL NO WEBHOOK ===');
    console.error('‚ùå Erro:', error);
    console.error('üìö Stack:', error.stack);
    return new Response(JSON.stringify({
      error: error.message || 'Erro interno do servidor',
      stack: error.stack
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  }
});
